[{"title":"如何区分浏览器刷新和关闭？","date":"2023-07-12T11:09:23.000Z","date_formatted":{"ll":"2023年7月12日","L":"2023/07/12","MM-DD":"07-12"},"updated":"2023-07-14T10:03:03.675Z","content":"起因\n起因呢是群里有人提问说如何区分浏览器刷新和关闭的事件，他需求在关闭浏览器时清空所有 localStorage 的数据，因为 uhhh————很奇怪，他们的项目要求不能使用 sessionStorage，只能使用 localStorage。\n所以这篇文章讨论的是如何在不使用 sessionStorage 的情况下，区分并实现浏览器刷新和关闭的事件。\n我一开始想到的是onbeforeunload或者unload事件，但是这个事件在浏览器关闭和刷新时都会触发的，\n而且各个浏览器厂商的加载流程也不近相同，所以这个事件并不能用来区分浏览器刷新和关闭。\n也包括其参数中的e.currentTarget.performance.navigation.type也是一样的。\n这个类型可以理解为当前的导航类型，而非下一步操作的类型，所以无法区分刷新和关闭。\n他可以确定你是第一次加载或者是刷新所进来的方式（之前的类型），但是无法确定你将要刷新还是关闭（下一步的操作）。\n然后是几个可行的方法：\n心跳包\n1.在页面上，添加 onunload 事件（伪代码）：\n123456789function myUnload(event) &#123;\tif (window.localStorage) &#123;\t\t// 标记页面正在被卸载\t\twindow.localStorage[&quot;myUnloadEventFlag&quot;] = new Date().getTime()\t&#125;\t//通知服务器我们想在几秒钟内断开用户的连接\taskServerToDisconnectUserInAFewSeconds()\t// 异步 AJAX call&#125;\n2.在您的页面上，将 onload 添加到 body（伪代码）：\n1234567891011121314function myLoad(event) &#123;\tif (window.localStorage) &#123;\t\tvar t0 = Number(window.localStorage[&quot;myUnloadEventFlag&quot;])\t\tif (isNaN(t0)) t0 = 0\t\tvar t1 = new Date().getTime()\t\tvar duration = t1 - t0\t\tif (duration &lt; 10 * 1000) &#123;\t\t\t// less than 10 seconds since the previous Unload event =&gt; it&#x27;s a browser reload (so cancel the disconnection request)\t\t\taskServerToCancelDisconnectionRequest() // asynchronous AJAX call\t\t&#125; else &#123;\t\t\t// last unload event was for a tab/window close =&gt; do whatever you want (I do nothing here)\t\t&#125;\t&#125;&#125;\n3.在服务器上，将断开连接请求收集到列表中，并设置一个计时器线程，该线程定期检查列表（我每 20 秒使用一次）。断开连接请求超时（即 5 秒消失）后，断开用户与服务器的连接。如果同时收到断开连接请求取消，则会从列表中删除相应的断开连接请求，以便用户不会断开连接。\n鼠标事件\n123456789101112$(window).on(&quot;mouseover&quot;, function () &#123;\twindow.onbeforeunload = null&#125;)$(window).on(&quot;mouseout&quot;, function () &#123;\twindow.onbeforeunload = ConfirmLeaveMessage&#125;)function ConfirmLeaveMessage() &#123;\t//return undefined;\treturn &quot;Are you sure you want to leave this page without saving?&quot;&#125;\n老实讲目前除了 sessionStorage 原生支持，还没有其他可靠的方案去判断浏览器为刷新或关闭，后续会继续更新本篇文章。\n","plink":"http://hibi.pages.dev/JavaScript/distinguish-between-browser-refresh-and-close/"},{"title":"阻止表单的默认行为时的行为","date":"2023-06-15T09:27:51.000Z","date_formatted":{"ll":"2023年6月15日","L":"2023/06/15","MM-DD":"06-15"},"updated":"2023-07-14T10:03:03.675Z","content":"想象有一个这样的表单：\n\n我们很多时候，并不想在表单提交以后刷新页面，就需要阻止默认的提交行为\n此时如果在 input 输入框输入之后按下 enter 会触发哪个函数？\n会触发整个表单中的第一个按钮？或者 input 输入框后的第一个按钮？再或者是具有type=&quot;submit&quot;的按钮？\n答案是会触发整个表单的第一个按钮，无论多少个输入框，总会触发整个表单的第一个按钮\n","thumbnail":"https://cdn.jsdelivr.net/gh/hibichann/picgo@main/202306150929505.png","plink":"http://hibi.pages.dev/JavaScript/form-default/"},{"title":"Javascript函数柯里化","date":"2023-06-12T08:58:05.000Z","date_formatted":{"ll":"2023年6月12日","L":"2023/06/12","MM-DD":"06-12"},"updated":"2023-07-14T10:03:03.675Z","content":"函数柯里化就是接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数,并且返回接受余下的参数且返回结果的新函数的函数。\n听起来有点绕，对吧？换句话就是：\n123fn(a, b, c)const curryFn = curry(fn)fn(a, b, c) === curryFn(a)(b)(c)\n我们要做的就是实现这个curry函数，它不会调用函数，它只是对函数做了一次转换\n先来一个简单的例子：\n1234567891011function add(x, y) &#123;\treturn x + y&#125;const curryAdd = curry(add)function curry(fn) &#123;\treturn (x) =&gt; &#123;\t\treturn (y) =&gt; &#123;\t\t\treturn fn(x, y)\t\t&#125;\t&#125;&#125;\n但这样的 curry 函数局限过大，那如何封装一个通用的 curry 函数呢？\n首先有两个目标，首先要确定函数执行的时机，然后就是参数收集的时机，如果参数没有收集完成，就继续收集和汇总参数。\n1234567891011function curry(fn) &#123;\treturn function curried(...args) &#123;\t\tif (args.length &gt;= fn.length) &#123;\t\t\treturn fn.apply(this, args)\t\t&#125; else &#123;\t\t\treturn function (...args2) &#123;\t\t\t\treturn curried.apply(this, args.concat(args2))\t\t\t&#125;\t\t&#125;\t&#125;&#125;\ncurry 函数接受一个普通函数 fn 并返回一个新的函数 curried。当 curried 被调用时，它会检查传递给它的参数数量是否足够调用 fn。如果足够，fn 就会被应用并返回结果。否则，curried 会返回一个新的函数，该函数使用 args.concat(args2) 将之前传递的参数和新传递的参数合并，然后再次调用 curried\n在这个过程中，每个返回的新函数都具有对原始函数 fn 的引用，并且可以收集任意数量的参数。最终，当最后一个新函数被调用并传入了所有需要的参数时，fn 被调用并返回结果。\n通过使用柯里化，我们可以创建更加灵活和重复使用的函数。\n","plink":"http://hibi.pages.dev/JavaScript/javascript-function-curry/"},{"title":"hexo在网页中插入一段自定义的代码","date":"2023-06-06T08:51:24.000Z","date_formatted":{"ll":"2023年6月6日","L":"2023/06/06","MM-DD":"06-06"},"updated":"2023-07-14T10:03:03.675Z","content":"在 hexo 根目录下创建文件夹scripts，然后写自己的代码进去\n有时我们想要修改主题的默认样式，但是主题是npm install安装的，不在themes目录下，也可通过这种方式注入一段 js\n1234567891011121314151617hexo.extend.filter.register(&quot;after_render:html&quot;, function (htmlContent) &#123;\t// 在此处输入你想要注入的 CSS 样式代码\tvar css = `.φbm &#123;        max-height: 500px;        object-fit: cover;        filter:brightness(0.95);        transition:all 0.2s;    &#125;    .φbm:hover&#123;        filter:unset;        transition:all 0.2s;        transform: scale(1.05);    &#125;    `\t// 将 CSS 样式代码插入到 HTML 中\treturn htmlContent.replace(/&lt;\\/head&gt;/i, &quot;&lt;style&gt;&quot; + css + &quot;&lt;/style&gt;&lt;/head&gt;&quot;)&#125;)\n这段代码就可以自动的被 hexo 注入到项目中，具体参考 hexo 插件手册\n","plink":"http://hibi.pages.dev/JavaScript/hexo-custom-plugin/"},{"title":"Ant Design的菜单常用配置","date":"2023-06-02T17:47:36.000Z","date_formatted":{"ll":"2023年6月2日","L":"2023/06/02","MM-DD":"06-02"},"updated":"2023-07-14T10:03:03.675Z","content":"1.实现手风琴模式\nAnt Design 默认没有为菜单组件提供手风琴模式的配置项，需要自己手动实现\n1234const handleChange = (Keys: string[]) =&gt; &#123;\t// 实现手风琴\tsetOpenKeys([Keys[Keys.length - 1]])&#125;\n把该函数绑定在 menu 的 onOpenChange回调函数上，原理是该事件会传递一个已打开的菜单项的key的数组，而且是 push 进去的，数组的最后一项总是最新打开的一项，所以可以把openkeys设置为该数组的最后一项\n2.在二级菜单下刷新页面时保留菜单选中和展开\n1234567891011121314let firstOpen = &quot;&quot;// 菜单的key设置为路由地址如&#x27;/user/info&#x27;// 获取当前Url地址const location = useLocation()//用于寻找key和当前页面地址对应项const findkey = (obj: ItemType) =&gt; obj?.key === location.pathnameitems.forEach((i: any) =&gt; &#123;    // 若菜单项的children不为空数组，去查找二级菜单中是否有对应的key\tif (i?.children &amp;&amp; i?.children.length &gt; 1 &amp;&amp; i?.children.find(findkey)) &#123;\t\tfirstOpen = i.key\t\tconsole.log(firstOpen)\t&#125;&#125;)const [openKeys, setOpenKeys] = useState([firstOpen] as string[])\n","plink":"http://hibi.pages.dev/React/ant-menu-common/"},{"title":"solidity函数","date":"2023-05-29T20:12:12.000Z","date_formatted":{"ll":"2023年5月29日","L":"2023/05/29","MM-DD":"05-29"},"updated":"2023-07-14T10:03:03.675Z","content":"function () {internal|external|public|private} [pure|view|payable] [returns ()]\n\n\nfunction：声明函数时的固定用法，想写函数，就要以 function 关键字开头。\n\n\n&lt;function name&gt;：函数名。\n\n\n(&lt;parameter types&gt;)：圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。\n\n\n&#123;internal|external|public|private&#125;：函数可见性说明符，一共 4 种。没标明函数类型的，默认public。合约之外的函数，即&quot;自由函数&quot;，始终具有隐含internal可见性。\n\npublic: 内部外部均可见。\nprivate: 只能从本合约内部访问，继承的合约也不能用。\nexternal: 只能从合约外部访问（但是可以用this.f()来调用，f是函数名）。\ninternal: 只能从合约内部访问，继承的合约可以用。\n\nNote 1: 没有标明可见性类型的函数，默认为public。\nNote 2: public|private|internal  也可用于修饰状态变量。 public变量会自动生成同名的getter函数，用于查询数值。\nNote 3: 没有标明可见性类型的状态变量，默认为internal。\n\n\n[pure|view|payable]：决定函数权限/功能的关键字。payable（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入ETH。\n\n\n[returns ()]：函数返回的变量类型和名称。\n\n\n关于 pure/view：\n被 pure 修饰的函数不可读取也不可修改链上数据，即纯粹的函数，函数内部无法直接读到合约内的变量，可以传入参数进行处理\n被 view 修饰的函数可以读取链上数据，但是不能修改\n默认为 payable 状态，可读可写\n\n注：实际上 pure/view 修饰的函数 gas 费会更高，猜测原因是由于默认支持链上数据读写，所以减少功能需要额外的标识，提升了 gas 费\n\n","plink":"http://hibi.pages.dev/Crypto/solidity-func/"},{"title":"错误的v-deep弃用警告","date":"2023-05-12T12:35:23.000Z","date_formatted":{"ll":"2023年5月12日","L":"2023/05/12","MM-DD":"05-12"},"updated":"2023-07-14T10:03:03.675Z","content":"在 sass/scss 项目中\n注意到项目中经常会有关于::v-deep的弃用警告，但是项目里又搜不到::v-deep\n\n\n然后也去查看了源码里关于这段报错的：\n\n打印 n.nodes：\n\n依旧无果，最终在 vuejs 的 issue 中找到:\nMisleading deprecation warning about “::v-deep”, when “:deep” is used in a nested block with SASS\n实际上是:deep 使用错误，应该是\n123:deep(.ClassName) &#123;\t// more rules&#125;\n而非\n123:deep .ClassName &#123;\t// more rules&#125;\n虽然后者也能工作，但是会错误地触发::v-deep 弃用警告\n顺带提了 issue，这个和上述 issue 并不完全重复\nincorrect warning about “::v-deep”, when “:deep” is wrongly used in a nested block with SASS\n\n2023-07-12:\nissue 相关 MR 已被合并，现在该警告样式已经修改\n\n","thumbnail":"https://cdn.jsdelivr.net/gh/hibichann/picgo@main/%E8%AD%A6%E5%91%8A.jpg","plink":"http://hibi.pages.dev/CSS/Incorrect-deep-deprecation-warning/"},{"title":"JS总能够保证对象顺序么","date":"2023-04-23T20:30:49.000Z","date_formatted":{"ll":"2023年4月23日","L":"2023/04/23","MM-DD":"04-23"},"updated":"2023-07-14T10:03:03.675Z","content":"当你创建了一个对象类似于：\n123var obj = &#123;&#125;obj.prop1 = &quot;Foo&quot;obj.prop2 = &quot;Bar&quot;\n那它是否总是能表现为：\n1&#123; prop1 : &quot;Foo&quot;, prop2 : &quot;Bar&quot; &#125;\n换句话说，js 是否总能保证对象的顺序？\n答案是能够保证，但不一定是插入顺序（ES 2015 之前）\n大部分浏览器都遵循这样的迭代规则：\n\n1.正整数键按升序排列（以及像“1”这样的字符串被解析为整数）\n2.字符串键，按插入顺序（ES 2015 保证这一点，所有浏览器都遵守）\n3.符号名称，按插入顺序排列（ES 2015 保证所有浏览器都符合此要求）\n\n一些较旧的浏览器采用的是前两种，按插入顺序迭代所有键。如果键可以被解析为整数，那么最好不要依赖于任何特定的迭代顺序。\n当前语言规范（ES 2015 及以后）中，插入顺序被保留，除非键被解析为正整数（包括“7”或“99”这样字符串包裹的整数），这种情况下行为因浏览器而异。比如，Chrome/V8 在键解析为数字时将不遵守插入顺序。\nDemo:\n\n\n在 chrome 中，整数键不遵守插入顺序，而是升序。\n后记\n这是一个很好的，现有的约定俗成的行为驱动规范完善的例子。es2015 之前并没有规范，但是 es2015 根据多数浏览器的实现制定了规则。\n但我们开发时并不能确定所处的运行环境，单就对象中 key 的顺序而言，最好不要依赖规范，而是自行遍历再过滤 key。或者采用 map 来保证 key 的顺序固定，map 中的键是有序的，map 在遍历的时候保证会按照插入顺序来迭代\n","plink":"http://hibi.pages.dev/JavaScript/js-object-sort/"},{"title":"在 element-plus 中保持菜单展开","date":"2023-02-22T20:35:12.000Z","date_formatted":{"ll":"2023年2月22日","L":"2023/02/22","MM-DD":"02-22"},"updated":"2023-07-14T10:03:03.675Z","content":"在 element plus 中，有时我们需要始终保持菜单的展开状态（如单独的全展开的分类页），而在 element plus 中并未提供相应的属性。\n但是可以首先为el-menu设置default-openeds 属性，值为需要展开的菜单。\n然后直接在el-menu的属性中，为菜单创建ref实例，并绑定close方法，在close方法中调用菜单实例身上的open方法来再次展开这个菜单。\n​ 需要保持菜单展开的情况许多时候还需要去除二级菜单后面的小箭头，可以通过为.el-sub-menu__icon-arrow设置 display: none !important; 来清除二级菜单后的按钮。\n模板：\n12345678910111213141516171819202122&lt;el-menu\tclass=&quot;el-menu-demo&quot;\t:ellipsis=&quot;false&quot;\t:default-openeds=&quot;[&#x27;2&#x27;, &#x27;2-4&#x27;]&quot;\t@close=&quot;keepopen&quot;\tref=&quot;menuRef&quot;&gt;\t&lt;el-menu-item index=&quot;0&quot;&gt;LOGO&lt;/el-menu-item&gt;\t&lt;div class=&quot;flex-grow&quot; /&gt;\t&lt;el-menu-item index=&quot;1&quot;&gt;Processing Center&lt;/el-menu-item&gt;\t&lt;el-sub-menu index=&quot;2&quot;&gt;\t\t&lt;template #title&gt;Workspace&lt;/template&gt;\t\t&lt;el-menu-item index=&quot;2-1&quot;&gt;item one&lt;/el-menu-item&gt;\t\t&lt;el-menu-item index=&quot;2-2&quot;&gt;item two&lt;/el-menu-item&gt;\t\t&lt;el-menu-item index=&quot;2-3&quot;&gt;item three&lt;/el-menu-item&gt;\t\t&lt;el-sub-menu index=&quot;2-4&quot;&gt;\t\t\t&lt;template #title&gt;item four&lt;/template&gt;\t\t\t&lt;el-menu-item index=&quot;2-4-1&quot;&gt;item one&lt;/el-menu-item&gt;\t\t\t&lt;el-menu-item index=&quot;2-4-2&quot;&gt;item two&lt;/el-menu-item&gt;\t\t\t&lt;el-menu-item index=&quot;2-4-3&quot;&gt;item three&lt;/el-menu-item&gt;\t\t&lt;/el-sub-menu&gt;\t&lt;/el-sub-menu&gt;&lt;/el-menu&gt;\n方法：\n1234const menuRef = ref &lt; any &gt; &quot;&quot;const keepopen = (s) =&gt; &#123;\tmenuRef.value.open(s)&#125;\n\n","thumbnail":"https://cdn.jsdelivr.net/gh/hibichann/picgo@main/img1.png","plink":"http://hibi.pages.dev/Vue/keep-menu-open-in-element-plus/"},{"title":"react中使用...批量传递props","date":"2023-02-09T21:56:12.000Z","date_formatted":{"ll":"2023年2月9日","L":"2023/02/09","MM-DD":"02-09"},"updated":"2023-07-14T10:03:03.675Z","content":"123456789101112131415161718192021class App extends React.Component &#123;\trender() &#123;\t\tconst &#123; name1, age &#125; = this.props\t\treturn (\t\t\t&lt;span&gt;\t\t\t\t&#123;name1&#125;,&#123;age&#125;\t\t\t&lt;/span&gt;\t\t)\t&#125;&#125;const p = &#123; name1: &quot;tom&quot;, age: 1 &#125;console.log(&#123; ...p &#125;) //输出对象pconsole.log(...p) //报错，没有迭代器iteratorroot.render(\t&lt;h1&gt;\t\t&lt;App &#123;...p&#125;&gt;&lt;/App&gt;\t\t&#123;/* 这里的花括号是react表明内部是js语法，而非es6展开运算符 */&#125;\t\t&#123;/* 此处传入的是name1=&quot;tom&quot;,age=1,而非p对象&#123;name1:&#x27;tom&#x27;,age:1&#125; */&#125;\t\t&#123;/* react为批量传递props提供了...迭代器，但仅能用于传递props */&#125;\t&lt;/h1&gt;)\n","plink":"http://hibi.pages.dev/React/react-three-dot-props/"},{"title":"Nginx部署刷新404","date":"2023-01-21T22:43:12.000Z","date_formatted":{"ll":"2023年1月21日","L":"2023/01/21","MM-DD":"01-21"},"updated":"2023-07-14T10:03:03.675Z","content":"解决刷新 404 问题：\n\n\n使用 hash 模式路由\n123456//vue3const router = createRouter(&#123;\tlinkActiveClass: &quot;active&quot;,\thistory: createWebHistory(),\troutes,&#125;)\n12345678//vue2const router = new Router(&#123;\tmode: &quot;hash&quot;,\troutes: [\t\t&#123; path: &quot;/&quot;, redirect: &quot;/login&quot; &#125;,\t\t&#123; path: &quot;/login&quot;, component: Login &#125;,\t],&#125;)\n\n\n在 nginx 中配置\n12345location / &#123;    root   html/dist;    index  index.html index.htm;    try_files $uri $uri/ /index.html;&#125;\n\n\n","plink":"http://hibi.pages.dev/Vue/nginx-404/"},{"title":"vue-router中使用i18n来进行网页标题的国际化","date":"2022-12-29T19:39:12.000Z","date_formatted":{"ll":"2022年12月29日","L":"2022/12/29","MM-DD":"12-29"},"updated":"2023-07-14T10:03:03.675Z","content":"思路很简单，在完成vue-i18n的安装后，第一次访问页面时候缓存默认语言，更改语言时，把当前语言缓存起来。在 i18n 中定义好不同语言的标题，然后在路由中引用作为 meta.title。在路由后置守卫中进行网页标题的修改。\n代码：\n首先完成 vue-i18n 配置：\n12345678910111213141516171819import &#123; createI18n &#125; from &quot;vue-i18n&quot;import zh from &quot;./zh&quot;import en from &quot;./en&quot;const i18n = createI18n(&#123;\tlegacy: false,\tlocale: &quot;zh&quot;, // 语言标识（缓存里面没有就用中文）\tmessages: &#123;\t\tzh,\t\ten,\t&#125;,&#125;)if (\twindow.localStorage.getItem(&quot;lang&quot;) !== &quot;zh&quot; &amp;&amp;\twindow.localStorage.getItem(&quot;lang&quot;) !== &quot;en&quot;) &#123;\twindow.localStorage.setItem(&quot;lang&quot;, &quot;zh&quot;)&#125;i18n.global.locale.value = window.localStorage.getItem(&quot;lang&quot;)export default i18n\nen.js:\n123456789101112export default &#123;\tmeg: &#123;\t\tlanguage: &quot;中文&quot;,\t\thome: &quot;Home&quot;,\t\tcategory: &quot;Category&quot;,\t\ttags: &quot;Tags&quot;,\t\ttest: &quot;Test&quot;,\t\tarticles: &quot;Articles&quot;,\t\talbum: &quot;Album&quot;,\t\tfinNew: &quot;Latest Articles&quot;,\t&#125;,&#125;\nzh.js:\n123456789101112export default &#123;\tmeg: &#123;\t\tlanguage: &quot;English&quot;,\t\thome: &quot;主页&quot;,\t\tcategory: &quot;分类&quot;,\t\ttags: &quot;标签&quot;,\t\ttest: &quot;测试&quot;,\t\tarticles: &quot;文章&quot;,\t\talbum: &quot;相册&quot;,\t\tfinNew: &quot;最新文章&quot;,\t&#125;,&#125;\nrouter.js\n1234567891011121314//路由中的定义方式  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    component: HomeView,    meta: &#123;      title: i18n.global.t(&#x27;meg.home&#x27;)    &#125;  &#125;//...//后置守卫router.afterEach((to, from) =&gt; &#123;  document.title = (i18n.global.locale.value === &#x27;zh&#x27;) ? &#x27;Hibi 博客站&#x27; : &#x27;Hibi Blog&#x27; + &#x27;-&#x27; + to.meta.title&#125;)\n","plink":"http://hibi.pages.dev/Vue/vue-router-i18n-html-title/"},{"title":"初识Vue3","date":"2022-07-26T10:39:43.000Z","date_formatted":{"ll":"2022年7月26日","L":"2022/07/26","MM-DD":"07-26"},"updated":"2023-07-14T10:03:03.675Z","content":"首次学习 vue3 时的笔记\n要从单个绑定获取多个 ref，请将  ref  绑定到一个更灵活的函数上：\n1&lt;div v-for=&quot;item in list&quot; :ref=&quot;setItemRef&quot;&gt;&lt;/div&gt;\n$attrs  现在包含了所有传递给组件的 attribute，包括  class  和  style。\nref()用于基本类型 reactive()用于对象或数组 实现深层的响应式数据\n具名插槽 slot=“qwe” &gt;&gt;&gt;&gt; v-solt:qwe\n自定义事件需要用emits接受\nsetup会接受两个参数\nprops接收后为 setup 第一个参数\ncontext \nattrs值为对象，包含了未被props接受的来自父组件中的属性，包括class和style\nslots收到的插槽内容\nemit分发自定义事件的函数，用于触发自定义事件\nexpose 指定组件向父组件暴露出去的公共函数\n123watch(prop, callback(newValue,oldValue)=&gt;&#123;    ...&#125;, &#123;immediate：true,deep:true&#125;)\nwatch 监听对象\n1 监听reactive定义的对象时 oldValue无法正确获取，\n2 监听reactive定义的对象时 强制开启了deep深层监视，无法关闭\n3 监听reactive定义对象中的某个属性 ，prop不能直接写ob1.prop需要写成返回值的样式 ()=&gt;ob1.prop\n4 监听对象中的深层属性如ob1.job，需要开启deep\nwatchEffect默认开启immediate，只监视回调函数中被使用的值\n生命周期\n创建前后&gt;&gt; setup()\n挂载前后onBeforeMount/onMounted\n更新前后onBeforeUpdated/onUpdated\n卸载前后onBeforeUnmount/onUnmounted\n自定义 hook\ntoRef 创建一个 ref 对象，其 value 值指向另一个对象的中的某个属性\n1const name = toRef(person, &quot;name&quot;)\ntoRefs可以展开一个 reactive 生成的 proxy 对象，让它成为一个普通对象，但该对象中的所有属性都是一个 ref 对象\n移除了.native\n想要为组件绑定如 click 这种原生事件时，只需注意不要在 emits 中接受即可，即可防止 click 被视为自定义事件，相同的，若要重载 click 事件，在 emits 中接收即可\n移除过滤器\nfragment 组件模板中可以不写根元素，减少了性能开销\nteleport组件可以将某一部分元素输送到某个指定元素中，更方便定位。\n异步组件\n使用defineAsyncComponent来引入一个异步组件，\n12import &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child=defineAsyncComponent(()=&gt;import(&#x27;./Components/Child&#x27;)\n12345678910&lt;suspense&gt;\t&lt;template #default&gt;\t\t&lt;!--此处放置真正的组件--&gt;\t\t&lt;todo-list /&gt;\t&lt;/template&gt;\t&lt;template #fallback&gt;\t\t&lt;!--此处放置骨架屏/渲染期间的显示--&gt;\t\t&lt;div&gt;Loading...&lt;/div&gt;\t&lt;/template&gt;&lt;/suspense&gt;\nshallowReactive只有第一层数据拥有响应式\n如同\n123456789let ob1=shallowReactive(&#123;    name:&quot;zhangsan&quot;,    age:18,    job:&#123;        j1:&quot;stuff&quot;        salary:20 // 深层次的数据将会是一个普通的对象    &#125;&#125;)\n这样的数据，采用 shallowReactive 无法令 j1 和 salary 拥有响应式\nshallowRef对于基本类型等同于 ref，对于对象类型，不会添加响应式\nreadonly 只读\n1ob1 = readonly(ob1)\n采用 readonly 不会令数据丢失响应式，但是会令数据不可更改\nshallowReadonly浅只读\n仅令 ob1 中的 name 和 age 不可更改，job 内部的属性可以更改\ntoRaw令一个 reactive 数据失去响应式\nmarkRaw令一个 reactive 数据永远不能转为响应式\nisRef:检查一个值是否为一个 ref 对象\nlsReactive:检查一个对象是否是由 reactive 创建的响应式代理\nisReadonly:检查—个对象是否是由 readonly 创建的只读代理\nisProxy:检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\nprovide/inject适用于祖孙通信\n祖先组件无需指名传值给哪个后代，后代也无需声明数据来源\n1provide(name, data)\n1inject(name)\ncustomRef 自定义 ref\n\n","plink":"http://hibi.pages.dev/Vue/first-vue3/"},{"title":"","date":"2023-07-14T10:03:03.675Z","updated":"2023-07-14T10:03:03.675Z","content":".φbm {\n\tmax-height: 500px;\n\tobject-fit: cover;\n}\n"},{"title":"关于","date":"2023-05-22T09:52:20.000Z","date_formatted":{"ll":"2023年5月22日","L":"2023/05/22","MM-DD":"05-22"},"updated":"2023-07-14T10:03:03.675Z","content":"Hibichann\n·Hibi, a full-time Front End Developer, passionate about creating user-friendly interfaces that provide a seamless browsing experience to users.\n·全职前端开发者，致力于创造用户友好的 UI 界面，并提供丝滑的浏览体验\n\nLanguages and Frameworks\n\n  \n  \n  \n  \n  \n  \n  \n\n\n  \n  \n  \n  \n  \n  \n  \n  \n\n\n总访客次数:\nVisitor Count:\n\n\n\n  Click to my github\n  \n    \n      \n      \n      \n      \n      \n      \n    \n  \n\n---\n\n","plink":"http://hibi.pages.dev/about/"},{"title":"友情链接","date":"2021-06-16T00:34:27.000Z","date_formatted":{"ll":"2021年6月16日","L":"2021/06/16","MM-DD":"06-16"},"updated":"2023-07-14T10:03:03.675Z","content":"\n   \n      \n         .links-content{\n         margin-top:1rem;\n         }\n         .link-navigation::after {\n         content: \" \";\n         display: block;\n         clear: both;\n         }\n         .card {\n         width: 45%;\n         font-size: 1rem;\n         padding: 10px 20px;\n         border-radius: 4px;\n         transition-duration: 0.15s;\n         margin-bottom: 1rem;\n         display:flex;\n         }\n         .card:nth-child(odd) {\n         float: left;\n         }\n         .card:nth-child(even) {\n         float: right;\n         }\n         .card:hover {\n         transform: scale(1.05);\n         box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);\n         }\n         .card a {\n         border:none;\n         }\n         .card .ava {\n         width: 3rem!important;\n         /* height: 3rem!important; */\n         margin:0!important;\n         margin-right: 1em!important;\n         border-radius:999px;\n         object-fit:cover\n         }\n         .card .card-header {\n         font-style: italic;\n         overflow: hidden;\n         width: 100%;\n         }\n         .card .card-header a {\n         font-style: normal;\n         color: #2bbc8a;\n         font-weight: bold;\n         text-decoration: none;\n         }\n         .card .card-header a:hover {\n         color: #d480aa;\n         text-decoration: none;\n         }\n         .card .card-header .info {\n         font-style:normal;\n         color:#a3a3a3;\n         font-size:14px;\n         min-width: 0;\n         overflow: hidden;\n         white-space: nowrap;\n         }\n         .link-re{\n            padding:10px;\n            background:#eee;\n            border-left:5px solid #555;\n            font-size:16px;\n         }\n      \n      \n         \n         \n         申请格式:\n         \n         &nbsp;&nbsp;&nbsp;&nbsp;头像链接:\n         &nbsp;&nbsp;&nbsp;&nbsp;博客链接:\n         &nbsp;&nbsp;&nbsp;&nbsp;简介:\n         \n      \n      \n      \n      \n        E-Mail\n      \n      \n        Github\n      \n      \n        Twitter\n      \n      \n        Telegram\n      \n      \n      \n      \n            \n               \n               \n                  \n                     FIREPLACE OF DESPAIR\n                  \n                  A jack of all trades and a one-man army.\n               \n            \n            \n               \n               \n                  \n                     Emil’s blog\n                  \n                  这是一个分享IT技术的小站。\n               \n            \n         \n      \n   \n\n","plink":"http://hibi.pages.dev/links/"},{"title":"QQ:321606998","date":"2023-07-14T10:03:03.675Z","date_formatted":{"ll":"2023年7月14日","L":"2023/07/14","MM-DD":"07-14"},"updated":"2023-07-14T10:03:03.675Z","content":"\n","plink":"http://hibi.pages.dev/redirect/"},{"title":"作品集","date":"2023-06-06T16:42:01.000Z","date_formatted":{"ll":"2023年6月6日","L":"2023/06/06","MM-DD":"06-06"},"updated":"2023-07-14T10:03:03.675Z","content":"&nbsp;DAPP Demo 基于 Goerli\n\n    Robo Punk\n    \n    \n\n\n&nbsp;自建博客\n\n\n@import url('https://fonts.googleapis.com/css?family=Press+Start+2P');\n@import url('https://fonts.googleapis.com/css?family=V2323');\n.title {\n  padding: 5px;\n  font-size: 20px;\n}\n.robo {\n  text-align: center;\n  display:block;\n  font-family: 'Press Start 2P', 'V2323';\n  color: white;\n  font-size: 48px;\n  letter-spacing: 5.5%;\n  text-shadow: 0 5px #000;\n  padding: 10px 50px;\n  border-radius: 5px;\n  user-select: none;\n  cursor: pointer;\n  background-color: rgb(255, 157, 28);\n}\n.krypt {\n  display:block;\n  border-radius: 5px;\n  user-select: none;\n  cursor: pointer;\n  padding: 10px 50px;\n  background-color: rgb(8, 21, 63);\n}\n.krypt img{\n    margin: 0 auto !important;\n    width:100%;\n    height:100%;\n}\n\n","plink":"http://hibi.pages.dev/things/"}]