[{"title":"solidity函数","date":"2023-05-29T20:12:12.000Z","date_formatted":{"ll":"2023年5月29日","L":"2023/05/29","MM-DD":"05-29"},"updated":"2023-05-29T02:19:53.916Z","content":"function () {internal|external|public|private} [pure|view|payable] [returns ()]\n\n\nfunction：声明函数时的固定用法，想写函数，就要以 function 关键字开头。\n\n\n&lt;function name&gt;：函数名。\n\n\n(&lt;parameter types&gt;)：圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。\n\n\n&#123;internal|external|public|private&#125;：函数可见性说明符，一共 4 种。没标明函数类型的，默认public。合约之外的函数，即&quot;自由函数&quot;，始终具有隐含internal可见性。\n\npublic: 内部外部均可见。\nprivate: 只能从本合约内部访问，继承的合约也不能用。\nexternal: 只能从合约外部访问（但是可以用this.f()来调用，f是函数名）。\ninternal: 只能从合约内部访问，继承的合约可以用。\n\nNote 1: 没有标明可见性类型的函数，默认为public。\nNote 2: public|private|internal  也可用于修饰状态变量。 public变量会自动生成同名的getter函数，用于查询数值。\nNote 3: 没有标明可见性类型的状态变量，默认为internal。\n\n\n[pure|view|payable]：决定函数权限/功能的关键字。payable（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入ETH。\n\n\n[returns ()]：函数返回的变量类型和名称。\n\n\n关于 pure/view：\n被 pure 修饰的函数不可读取也不可修改链上数据，即纯粹的函数，函数内部无法直接读到合约内的变量，可以传入参数进行处理\n被 view 修饰的函数可以读取链上数据，但是不能修改\n默认为 payable 状态，可读可写\n\n注：实际上 pure/view 修饰的函数 gas 费会更高，猜测原因是由于默认支持链上数据读写，所以减少功能需要额外的标识，提升了 gas 费\n\n","plink":"http://hibi.pages.dev/2023/05/29/solidity-func/"},{"title":"错误的v-deep弃用警告","date":"2023-05-12T12:35:23.000Z","date_formatted":{"ll":"2023年5月12日","L":"2023/05/12","MM-DD":"05-12"},"updated":"2023-05-29T02:19:53.916Z","content":"在 sass/scss 项目中\n注意到项目中经常会有关于::v-deep的弃用警告，但是项目里又搜不到::v-deep\n\n\n然后也去查看了源码里关于这段报错的：\n\n打印 n.nodes：\n\n依旧无果，最终在 vuejs 的 issue 中找到:\nMisleading deprecation warning about “::v-deep”, when “:deep” is used in a nested block with SASS\n实际上是:deep 使用错误，应该是\n123:deep(.ClassName) &#123;\t// more rules&#125;\n而非\n123:deep .ClassName &#123;\t// more rules&#125;\n虽然后者也能工作，但是会错误地触发::v-deep 弃用警告\n","thumbnail":"https://cdn.jsdelivr.net/gh/hibichann/picgo@main/%E8%AD%A6%E5%91%8A.jpg","color":"#26303A","plink":"http://hibi.pages.dev/2023/05/12/Incorrect-deep-deprecation-warning/"},{"title":"JS总能够保证对象顺序么","date":"2023-04-23T20:30:49.000Z","date_formatted":{"ll":"2023年4月23日","L":"2023/04/23","MM-DD":"04-23"},"updated":"2023-05-29T02:19:53.916Z","content":"当你创建了一个对象类似于：\n123var obj = &#123;&#125;obj.prop1 = &quot;Foo&quot;obj.prop2 = &quot;Bar&quot;\n那它是否总是能表现为：\n1&#123; prop1 : &quot;Foo&quot;, prop2 : &quot;Bar&quot; &#125;\n换句话说，js 是否总能保证对象的顺序？\n答案是能够保证，但不一定是插入顺序（ES 2015 之前）\n大部分浏览器都遵循这样的迭代规则：\n\n1.正整数键按升序排列（以及像“1”这样的字符串被解析为整数）\n2.字符串键，按插入顺序（ES 2015 保证这一点，所有浏览器都遵守）\n3.符号名称，按插入顺序排列（ES 2015 保证所有浏览器都符合此要求）\n\n一些较旧的浏览器采用的是前两种，按插入顺序迭代所有键。如果键可以被解析为整数，那么最好不要依赖于任何特定的迭代顺序。\n当前语言规范（ES 2015 及以后）中，插入顺序被保留，除非键被解析为正整数（包括“7”或“99”这样字符串包裹的整数），这种情况下行为因浏览器而异。比如，Chrome/V8 在键解析为数字时将不遵守插入顺序。\nDemo:\n\n\n在 chrome 中，整数键不遵守插入顺序，而是升序。\n后记\n这是一个很好的，现有的约定俗成的行为驱动规范完善的例子，但开发时并不能确定所处的运行环境，但就对象中 key 的顺序而言，最好不要依赖规范，而是自行遍历再过滤 key。或者采用 map 来保证 key 的顺序固定，map 中的键是有序的，map 在遍历的时候保证会按照插入顺序来迭代\n","plink":"http://hibi.pages.dev/2023/04/23/js-object-sort/"},{"title":"在 element-plus 中保持菜单展开","date":"2023-02-22T20:35:12.000Z","date_formatted":{"ll":"2023年2月22日","L":"2023/02/22","MM-DD":"02-22"},"updated":"2023-05-29T02:19:53.916Z","content":"​\n在element plus中，有时我们需要始终保持菜单的展开状态（如单独的全展开的分类页），而在 element plus 中并未提供相应的属性。\n但是可以首先为el-menu设置default-openeds 属性，值为需要展开的菜单。\n然后直接在el-menu的属性中，为菜单创建ref实例，并绑定close方法，在close方法中调用菜单实例身上的open方法来再次展开这个菜单。\n​需要保持菜单展开的情况许多时候还需要去除二级菜单后面的小箭头，可以通过为.el-sub-menu__icon-arrow设置 display: none !important; 来清除二级菜单后的按钮。\n模板：\n12345678910111213141516171819202122&lt;el-menu\tclass=&quot;el-menu-demo&quot;\t:ellipsis=&quot;false&quot;\t:default-openeds=&quot;[&#x27;2&#x27;, &#x27;2-4&#x27;]&quot;\t@close=&quot;keepopen&quot;\tref=&quot;menuRef&quot;&gt;\t&lt;el-menu-item index=&quot;0&quot;&gt;LOGO&lt;/el-menu-item&gt;\t&lt;div class=&quot;flex-grow&quot; /&gt;\t&lt;el-menu-item index=&quot;1&quot;&gt;Processing Center&lt;/el-menu-item&gt;\t&lt;el-sub-menu index=&quot;2&quot;&gt;\t\t&lt;template #title&gt;Workspace&lt;/template&gt;\t\t&lt;el-menu-item index=&quot;2-1&quot;&gt;item one&lt;/el-menu-item&gt;\t\t&lt;el-menu-item index=&quot;2-2&quot;&gt;item two&lt;/el-menu-item&gt;\t\t&lt;el-menu-item index=&quot;2-3&quot;&gt;item three&lt;/el-menu-item&gt;\t\t&lt;el-sub-menu index=&quot;2-4&quot;&gt;\t\t\t&lt;template #title&gt;item four&lt;/template&gt;\t\t\t&lt;el-menu-item index=&quot;2-4-1&quot;&gt;item one&lt;/el-menu-item&gt;\t\t\t&lt;el-menu-item index=&quot;2-4-2&quot;&gt;item two&lt;/el-menu-item&gt;\t\t\t&lt;el-menu-item index=&quot;2-4-3&quot;&gt;item three&lt;/el-menu-item&gt;\t\t&lt;/el-sub-menu&gt;\t&lt;/el-sub-menu&gt;&lt;/el-menu&gt;\n方法：\n1234const menuRef = ref &lt; any &gt; &quot;&quot;const keepopen = (s) =&gt; &#123;\tmenuRef.value.open(s)&#125;\n\n","plink":"http://hibi.pages.dev/2023/02/22/keep-menu-open-in-element-plus/"},{"title":"react中使用...批量传递props","date":"2023-02-09T21:56:12.000Z","date_formatted":{"ll":"2023年2月9日","L":"2023/02/09","MM-DD":"02-09"},"updated":"2023-05-29T02:19:53.916Z","content":"123456789101112131415161718192021class App extends React.Component &#123;    render() &#123;        const &#123; name1, age &#125; = this.props        return (            &lt;span&gt;                &#123;name1&#125;,&#123;age&#125;            &lt;/span&gt;        )    &#125;&#125;const p = &#123; name1: &quot;tom&quot;, age: 1 &#125;console.log(&#123; ...p &#125;) //输出对象pconsole.log(...p) //报错，没有迭代器iteratorroot.render(    &lt;h1&gt;        &lt;App &#123;...p&#125;&gt;&lt;/App&gt;        &#123;/* 这里的花括号是react表明内部是js语法，而非es6展开运算符 */&#125;        &#123;/* 此处传入的是name1=&quot;tom&quot;,age=1,而非p对象&#123;name1:&#x27;tom&#x27;,age:1&#125; */&#125;        &#123;/* react为批量传递props提供了...迭代器，但仅能用于传递props */&#125;    &lt;/h1&gt;)\n","plink":"http://hibi.pages.dev/2023/02/09/react-three-dot-props/"},{"title":"Nginx部署刷新404","date":"2023-01-21T22:43:12.000Z","date_formatted":{"ll":"2023年1月21日","L":"2023/01/21","MM-DD":"01-21"},"updated":"2023-05-29T02:19:53.916Z","content":"解决刷新 404 问题：\n\n\n使用 hash 模式路由\n123456//vue3const router = createRouter(&#123;\tlinkActiveClass: &quot;active&quot;,\thistory: createWebHistory(),\troutes,&#125;)\n12345678//vue2const router = new Router(&#123;\tmode: &quot;hash&quot;,\troutes: [\t\t&#123; path: &quot;/&quot;, redirect: &quot;/login&quot; &#125;,\t\t&#123; path: &quot;/login&quot;, component: Login &#125;,\t],&#125;)\n\n\n在 nginx 中配置\n12345location / &#123;    root   html/dist;    index  index.html index.htm;    try_files $uri $uri/ /index.html;&#125;\n\n\n","plink":"http://hibi.pages.dev/2023/01/21/nginx-404/"},{"title":"vue-router中使用i18n来进行网页标题的国际化","date":"2022-12-29T19:39:12.000Z","date_formatted":{"ll":"2022年12月29日","L":"2022/12/29","MM-DD":"12-29"},"updated":"2023-05-29T02:19:53.916Z","content":"思路很简单，在完成vue-i18n的安装后，第一次访问页面时候缓存默认语言，更改语言时，把当前语言缓存起来。在 i18n 中定义好不同语言的标题，然后在路由中引用作为 meta.title。在路由后置守卫中进行网页标题的修改。\n代码：\n首先完成 vue-i18n 配置：\n12345678910111213141516171819import &#123; createI18n &#125; from &quot;vue-i18n&quot;import zh from &quot;./zh&quot;import en from &quot;./en&quot;const i18n = createI18n(&#123;\tlegacy: false,\tlocale: &quot;zh&quot;, // 语言标识（缓存里面没有就用中文）\tmessages: &#123;\t\tzh,\t\ten,\t&#125;,&#125;)if (\twindow.localStorage.getItem(&quot;lang&quot;) !== &quot;zh&quot; &amp;&amp;\twindow.localStorage.getItem(&quot;lang&quot;) !== &quot;en&quot;) &#123;\twindow.localStorage.setItem(&quot;lang&quot;, &quot;zh&quot;)&#125;i18n.global.locale.value = window.localStorage.getItem(&quot;lang&quot;)export default i18n\nen.js:\n123456789101112export default &#123;\tmeg: &#123;\t\tlanguage: &quot;中文&quot;,\t\thome: &quot;Home&quot;,\t\tcategory: &quot;Category&quot;,\t\ttags: &quot;Tags&quot;,\t\ttest: &quot;Test&quot;,\t\tarticles: &quot;Articles&quot;,\t\talbum: &quot;Album&quot;,\t\tfinNew: &quot;Latest Articles&quot;,\t&#125;,&#125;\nzh.js:\n123456789101112export default &#123;\tmeg: &#123;\t\tlanguage: &quot;English&quot;,\t\thome: &quot;主页&quot;,\t\tcategory: &quot;分类&quot;,\t\ttags: &quot;标签&quot;,\t\ttest: &quot;测试&quot;,\t\tarticles: &quot;文章&quot;,\t\talbum: &quot;相册&quot;,\t\tfinNew: &quot;最新文章&quot;,\t&#125;,&#125;\nrouter.js\n1234567891011121314//路由中的定义方式  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    component: HomeView,    meta: &#123;      title: i18n.global.t(&#x27;meg.home&#x27;)    &#125;  &#125;//...//后置守卫router.afterEach((to, from) =&gt; &#123;  document.title = (i18n.global.locale.value === &#x27;zh&#x27;) ? &#x27;Hibi 博客站&#x27; : &#x27;Hibi Blog&#x27; + &#x27;-&#x27; + to.meta.title&#125;)\n","plink":"http://hibi.pages.dev/2022/12/29/vue-router-i18n-html-title/"},{"title":"初识Vue3","date":"2022-07-26T10:39:43.000Z","date_formatted":{"ll":"2022年7月26日","L":"2022/07/26","MM-DD":"07-26"},"updated":"2023-05-29T02:19:53.916Z","content":"首次学习 vue3 时的笔记\n要从单个绑定获取多个 ref，请将  ref  绑定到一个更灵活的函数上：\n1&lt;div v-for=&quot;item in list&quot; :ref=&quot;setItemRef&quot;&gt;&lt;/div&gt;\n$attrs  现在包含了所有传递给组件的 attribute，包括  class  和  style。\nref()用于基本类型 reactive()用于对象或数组 实现深层的响应式数据\n具名插槽 slot=“qwe” &gt;&gt;&gt;&gt; v-solt:qwe\n自定义事件需要用emits接受\nsetup会接受两个参数\nprops接收后为 setup 第一个参数\ncontext \nattrs值为对象，包含了未被props接受的来自父组件中的属性，包括class和style\nslots收到的插槽内容\nemit分发自定义事件的函数，用于触发自定义事件\nexpose 指定组件向父组件暴露出去的公共函数\n123watch(prop, callback(newValue,oldValue)=&gt;&#123;    ...&#125;, &#123;immediate：true,deep:true&#125;)\nwatch 监听对象\n1 监听reactive定义的对象时 oldValue无法正确获取，\n2 监听reactive定义的对象时 强制开启了deep深层监视，无法关闭\n3 监听reactive定义对象中的某个属性 ，prop不能直接写ob1.prop需要写成返回值的样式 ()=&gt;ob1.prop\n4 监听对象中的深层属性如ob1.job，需要开启deep\nwatchEffect默认开启immediate，只监视回调函数中被使用的值\n生命周期\n创建前后&gt;&gt; setup()\n挂载前后onBeforeMount/onMounted\n更新前后onBeforeUpdated/onUpdated\n卸载前后onBeforeUnmount/onUnmounted\n自定义 hook\ntoRef 创建一个 ref 对象，其 value 值指向另一个对象的中的某个属性\n1const name = toRef(person, &quot;name&quot;)\ntoRefs可以展开一个 reactive 生成的 proxy 对象，让它成为一个普通对象，但该对象中的所有属性都是一个 ref 对象\n移除了.native\n想要为组件绑定如 click 这种原生事件时，只需注意不要在 emits 中接受即可，即可防止 click 被视为自定义事件，相同的，若要重载 click 事件，在 emits 中接收即可\n移除过滤器\nfragment 组件模板中可以不写根元素，减少了性能开销\nteleport组件可以将某一部分元素输送到某个指定元素中，更方便定位。\n异步组件\n使用defineAsyncComponent来引入一个异步组件，\n12import &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child=defineAsyncComponent(()=&gt;import(&#x27;./Components/Child&#x27;)\n12345678910&lt;suspense&gt;\t&lt;template #default&gt;\t\t&lt;!--此处放置真正的组件--&gt;\t\t&lt;todo-list /&gt;\t&lt;/template&gt;\t&lt;template #fallback&gt;\t\t&lt;!--此处放置骨架屏/渲染期间的显示--&gt;\t\t&lt;div&gt;Loading...&lt;/div&gt;\t&lt;/template&gt;&lt;/suspense&gt;\nshallowReactive只有第一层数据拥有响应式\n如同\n123456789let ob1=shallowReactive(&#123;    name:&quot;zhangsan&quot;,    age:18,    job:&#123;        j1:&quot;stuff&quot;        salary:20 // 深层次的数据将会是一个普通的对象    &#125;&#125;)\n这样的数据，采用 shallowReactive 无法令 j1 和 salary 拥有响应式\nshallowRef对于基本类型等同于 ref，对于对象类型，不会添加响应式\nreadonly 只读\n1ob1 = readonly(ob1)\n采用 readonly 不会令数据丢失响应式，但是会令数据不可更改\nshallowReadonly浅只读\n仅令 ob1 中的 name 和 age 不可更改，job 内部的属性可以更改\ntoRaw令一个 reactive 数据失去响应式\nmarkRaw令一个 reactive 数据永远不能转为响应式\nisRef:检查一个值是否为一个 ref 对象\nlsReactive:检查一个对象是否是由 reactive 创建的响应式代理\nisReadonly:检查—个对象是否是由 readonly 创建的只读代理\nisProxy:检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\nprovide/inject适用于祖孙通信\n祖先组件无需指名传值给哪个后代，后代也无需声明数据来源\n1provide(name, data)\n1inject(name)\ncustomRef 自定义 ref\n\n","plink":"http://hibi.pages.dev/2022/07/26/first-vue3/"},{"title":"Tags","date":"2023-05-25T16:03:25.000Z","updated":"2023-05-29T02:19:53.916Z","content":""},{"title":"关于","date":"2023-05-22T09:52:20.000Z","date_formatted":{"ll":"2023年5月22日","L":"2023/05/22","MM-DD":"05-22"},"updated":"2023-05-29T02:19:53.916Z","content":"Hibichann\n·Hibi, a full-time Front End Developer, passionate about creating user-friendly interfaces that provide a seamless browsing experience to users.\n·全职前端开发者，致力于创造用户友好的 UI 界面，并提供丝滑的浏览体验\n\nLanguages and Frameworks\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n总访客次数:\nVisitor Count:\n\n\n\n  \n    \n    \n    \n    \n    \n    \n  \n\n---\n\n","plink":"http://hibi.pages.dev/about/"}]