{"title":"Javascript函数柯里化","date":"2023-06-12T08:58:05.000Z","date_formatted":{"ll":"2023年6月12日","L":"2023/06/12","MM-DD":"06-12"},"link":"JavaScript/javascript-function-curry","tags":["JavaScript"],"categories":["JavaScript"],"updated":"2023-08-01T07:29:08.079Z","content":"<p>函数柯里化就是接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数,并且返回接受余下的参数且返回结果的新函数的函数。<br>\n听起来有点绕，对吧？换句话就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fn</span>(a, b, c)</span><br><span class=\"line\"><span class=\"keyword\">const</span> curryFn = <span class=\"title function_\">curry</span>(fn)</span><br><span class=\"line\"><span class=\"title function_\">fn</span>(a, b, c) === <span class=\"title function_\">curryFn</span>(a)(b)(c)</span><br></pre></td></tr></table></figure>\n<p>我们要做的就是实现这个<code>curry</code>函数，它不会调用函数，它只是对函数做了一次转换</p>\n<p>先来一个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">x, y</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> curryAdd = <span class=\"title function_\">curry</span>(add)</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">curry</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"title function_\">fn</span>(x, y)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但这样的 curry 函数局限过大，那如何封装一个通用的 curry 函数呢？</p>\n<p>首先有两个目标，首先要确定函数执行的时机，然后就是参数收集的时机，如果参数没有收集完成，就继续收集和汇总参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">curry</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">curried</span>(<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (args.<span class=\"property\">length</span> &gt;= fn.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args2</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> curried.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args.<span class=\"title function_\">concat</span>(args2))</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>curry</code> 函数接受一个普通函数 <code>fn</code> 并返回一个新的函数 <code>curried。当</code> <code>curried</code> 被调用时，它会检查传递给它的参数数量是否足够调用 <code>fn</code>。如果足够，<code>fn</code> 就会被应用并返回结果。否则，<code>curried</code> 会返回一个新的函数，该函数使用 <code>args.concat(args2)</code> 将之前传递的参数和新传递的参数合并，然后再次调用 <code>curried</code></p>\n<p>在这个过程中，每个返回的新函数都具有对原始函数 <code>fn</code> 的引用，并且可以收集任意数量的参数。最终，当最后一个新函数被调用并传入了所有需要的参数时，<code>fn</code> 被调用并返回结果。</p>\n<p>通过使用柯里化，我们可以创建更加灵活和重复使用的函数。</p>\n","prev":{"title":"阻止表单的默认行为时的行为","link":"JavaScript/form-default"},"next":{"title":"hexo在网页中插入一段自定义的代码","link":"JavaScript/hexo-custom-plugin"},"plink":"http://hibi.pages.dev/JavaScript/javascript-function-curry/","reading_time":"489 字约 3 分钟"}